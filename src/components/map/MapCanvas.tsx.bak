import React, { useRef, useEffect, useState } from 'react';
import { Box, Typography } from '@mui/material';
import { useMapStore } from '../../stores/mapStore';
import { useEquipmentStore } from '../../stores/equipmentStore';
import { CalibrationService } from '../../services/calibrationService';
import CalibrationDialog from '../calibration/CalibrationDialog';

const MapCanvas: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
  
  // Get state from stores
  const { 
    scale, 
    position, 
    imageUrl,
    imageLocked,
    isCalibrationMode,
    activeCalibrationLine,
    currentCalibrationLine,
    startCalibrationLine,
    completeCalibrationLine,
    pixelsPerMeter,
    setScale,
    setPosition,
    showGrid,
    gridSpacing,
    gridColor
  } = useMapStore();
  
  const { addItemFromTemplate, items: equipmentItems, selectItem, selectedId, moveItem, updateItemDimensions } = useEquipmentStore();

  // Local state
  const [calibrationDialogOpen, setCalibrationDialogOpen] = useState(false);
  const [pendingCalibrationData, setPendingCalibrationData] = useState<{
    endPoint: { x: number; y: number; id: string };
    pixelDistance: number;
  } | null>(null);
  const [isDraggingEquipment, setIsDraggingEquipment] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [panStartPosition, setPanStartPosition] = useState({ x: 0, y: 0 });
  const [loadedImage, setLoadedImage] = useState<HTMLImageElement | null>(null);

  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (!containerRef.current) return;
      const rect = containerRef.current.getBoundingClientRect();
      setCanvasSize({ width: rect.width, height: rect.height });
    };
    
    window.addEventListener('resize', handleResize);
    handleResize();
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // Load image when imageUrl changes
  useEffect(() => {
    if (!imageUrl) {
      setLoadedImage(null);
      return;
    }
    
    const img = new Image();
    img.onload = () => {
      setLoadedImage(img);
    };
    img.onerror = () => {
      console.error('Failed to load image:', imageUrl);
      setLoadedImage(null);
    };
    img.src = imageUrl;
  }, [imageUrl]);

  // Helper functions
  const getCanvasCoordinates = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    
    const rect = canvas.getBoundingClientRect();
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;
    
    const canvasX = (screenX - position.x) / scale;
    const canvasY = (screenY - position.y) / scale;
    
    return { x: canvasX, y: canvasY };
  };

  const getEquipmentAtPoint = (x: number, y: number) => {
    for (let i = equipmentItems.length - 1; i >= 0; i--) {
      const item = equipmentItems[i];
      if (x >= item.x && x <= item.x + item.width &&
          y >= item.y && y <= item.y + item.height) {
        return item;
      }
    }
    return null;
  };

  // Event handlers
  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const { x, y } = getCanvasCoordinates(event);
    
    if (isCalibrationMode) {
      const point = { id: `point-${Date.now()}`, x, y };
      
      if (!currentCalibrationLine?.startPoint) {
        startCalibrationLine(point);
      } else {
        const pixelDistance = CalibrationService.calculatePixelDistance(currentCalibrationLine.startPoint, point);
        setPendingCalibrationData({ endPoint: point, pixelDistance });
        setCalibrationDialogOpen(true);
      }
    } else {
      const clickedEquipment = getEquipmentAtPoint(x, y);
      if (clickedEquipment) {
        selectItem(clickedEquipment.id);
      } else {
        selectItem(null);
      }
    }
  };

  const handleMouseDown = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (isCalibrationMode) return;
    
    const { x, y } = getCanvasCoordinates(event);
    const clickedEquipment = getEquipmentAtPoint(x, y);
    
    if (clickedEquipment) {
      selectItem(clickedEquipment.id);
      setIsDraggingEquipment(true);
      setDragOffset({
        x: x - clickedEquipment.x,
        y: y - clickedEquipment.y
      });
    } else if (!imageLocked || !imageUrl) {
      // Canvas panning (only if image is not locked or no image loaded)
      setIsPanning(true);
      setPanStart({ x: event.clientX, y: event.clientY });
      setPanStartPosition({ x: position.x, y: position.y });
    }
  };

  const handleMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (isDraggingEquipment && selectedId) {
      const { x, y } = getCanvasCoordinates(event);
      moveItem(selectedId, x - dragOffset.x, y - dragOffset.y);
    } else if (isPanning) {
      const deltaX = event.clientX - panStart.x;
      const deltaY = event.clientY - panStart.y;
      
      setPosition({
        x: panStartPosition.x + deltaX,
        y: panStartPosition.y + deltaY
      });
    }
  };

  const handleMouseUp = () => {
    setIsDraggingEquipment(false);
    setDragOffset({ x: 0, y: 0 });
    setIsPanning(false);
  };

  const handleDragOver = (event: React.DragEvent<HTMLCanvasElement>) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
  };

  const handleDrop = (event: React.DragEvent<HTMLCanvasElement>) => {
    event.preventDefault();
    
    try {
      const data = JSON.parse(event.dataTransfer.getData('application/json'));
      
      if (data.type === 'equipment') {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const canvasX = (event.clientX - rect.left) * scaleX;
        const canvasY = (event.clientY - rect.top) * scaleY;
        
        const x = (canvasX - position.x) / scale;
        const y = (canvasY - position.y) / scale;
        
        addItemFromTemplate(data.templateId, x, y, pixelsPerMeter);
      }
    } catch (error) {
      console.error('Failed to handle drop:', error);
    }
  };

  const handleCalibrationConfirm = (distance: number) => {
    if (!pendingCalibrationData || !currentCalibrationLine?.startPoint) return;
    
    const endPointWithId = {
      ...pendingCalibrationData.endPoint,
      id: `point-${Date.now()}`
    };
    
    // Calculate the new pixelsPerMeter BEFORE updating equipment
    const pixelDistance = CalibrationService.calculatePixelDistance(
      currentCalibrationLine.startPoint, 
      endPointWithId
    );
    const newPixelsPerMeter = pixelDistance / distance;
    
    // Complete the calibration line
    completeCalibrationLine(endPointWithId, distance);
    
    // Update equipment dimensions with the NEW pixelsPerMeter value
    updateItemDimensions(newPixelsPerMeter);
    
    setPendingCalibrationData(null);
    setCalibrationDialogOpen(false);
  };

  const handleCalibrationDialogClose = () => {
    setPendingCalibrationData(null);
    setCalibrationDialogOpen(false);
  };

  // Drawing functions
  const drawActiveCalibrationLine = React.useCallback((ctx: CanvasRenderingContext2D) => {
    if (!activeCalibrationLine) return;
    
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 5]);
    ctx.beginPath();
    ctx.moveTo(activeCalibrationLine.startPoint.x, activeCalibrationLine.startPoint.y);
    ctx.lineTo(activeCalibrationLine.endPoint.x, activeCalibrationLine.endPoint.y);
    ctx.stroke();
    
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(activeCalibrationLine.startPoint.x, activeCalibrationLine.startPoint.y, 8, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(activeCalibrationLine.endPoint.x, activeCalibrationLine.endPoint.y, 8, 0, 2 * Math.PI);
    ctx.fill();
    
    const midX = (activeCalibrationLine.startPoint.x + activeCalibrationLine.endPoint.x) / 2;
    const midY = (activeCalibrationLine.startPoint.y + activeCalibrationLine.endPoint.y) / 2;
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(
      CalibrationService.formatDistance(activeCalibrationLine.realWorldDistance),
      midX,
      midY - 10
    );
  }, [activeCalibrationLine]);

  const drawCurrentCalibrationLine = React.useCallback((ctx: CanvasRenderingContext2D) => {
    if (!currentCalibrationLine?.startPoint) return;
    
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(currentCalibrationLine.startPoint.x, currentCalibrationLine.startPoint.y, 6, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(
      'Start Point',
      currentCalibrationLine.startPoint.x,
      currentCalibrationLine.startPoint.y - 15
    );
  }, [currentCalibrationLine]);

  const drawEquipmentItems = React.useCallback((ctx: CanvasRenderingContext2D) => {
    equipmentItems.forEach((item) => {
      ctx.fillStyle = item.color;
      ctx.globalAlpha = 0.7;
      ctx.fillRect(item.x, item.y, item.width, item.height);
      
      ctx.globalAlpha = 1;
      ctx.strokeStyle = selectedId === item.id ? '#ffffff' : item.color;
      ctx.lineWidth = selectedId === item.id ? 3 : 2;
      ctx.setLineDash(selectedId === item.id ? [5, 5] : []);
      ctx.strokeRect(item.x, item.y, item.width, item.height);
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(
        item.name,
        item.x + item.width / 2,
        item.y + item.height / 2
      );
    });
  }, [equipmentItems, selectedId]);

  const drawGrid = React.useCallback((ctx: CanvasRenderingContext2D) => {
    if (!showGrid || pixelsPerMeter <= 0) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    ctx.save();
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.3;
    
    const gridSpacingPixels = gridSpacing * pixelsPerMeter * scale;
    
    if (gridSpacingPixels < 10) {
      ctx.restore();
      return;
    }
    
    const offsetX = position.x % gridSpacingPixels;
    const offsetY = position.y % gridSpacingPixels;
    
    for (let x = offsetX; x < canvas.width + gridSpacingPixels; x += gridSpacingPixels) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    
    for (let y = offsetY; y < canvas.height + gridSpacingPixels; y += gridSpacingPixels) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    
    ctx.restore();
  }, [showGrid, pixelsPerMeter, scale, position, gridSpacing, gridColor]);

  // Draw on canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(position.x, position.y);
    ctx.scale(scale, scale);
    
    if (loadedImage) {
      ctx.drawImage(loadedImage, 0, 0);
    }
    
    drawActiveCalibrationLine(ctx);
    drawCurrentCalibrationLine(ctx);
    drawEquipmentItems(ctx);
    
    ctx.restore();
    drawGrid(ctx);
  }, [loadedImage, scale, position, drawGrid, drawActiveCalibrationLine, drawCurrentCalibrationLine, drawEquipmentItems]);
    ctx.restore();
    drawGrid(ctx);
  }, [loadedImage, scale, position, drawGrid, drawActiveCalibrationLine, drawCurrentCalibrationLine, drawEquipmentItems]);

  // Add wheel event listener for smooth zoom
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const wheelHandler = (event: WheelEvent) => {
      event.preventDefault();
      
      // Get mouse position relative to canvas
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      // Calculate a smooth zoom factor based on the delta magnitude for slower/smoother zoom
      // Smaller delta = more gentle zoom
      const deltaMagnitude = Math.abs(event.deltaY);
      const baseZoomFactor = 0.01; // Base zoom factor (more gentle)
      const maxZoomFactor = 0.05; // Maximum zoom factor
      
      // Calculate smooth zoom factor - capped between base and max
      const smoothZoomFactor = Math.min(maxZoomFactor, 
                               baseZoomFactor + (deltaMagnitude / 1000));
      
      // Apply zoom direction
      const zoomFactor = event.deltaY > 0 ? 
                     (1 - smoothZoomFactor) : 
                     (1 + smoothZoomFactor);
                     
      const newScale = Math.max(0.1, Math.min(5, scale * zoomFactor));
      
      if (imageLocked && imageUrl && !selectedId) {
        // If image is locked and no equipment selected, only move/scale equipment items
        // This keeps the image fixed while everything else moves
        const scaleRatio = newScale / scale;
        
        // Calculate canvas coordinates
        const canvasMouseX = (mouseX - position.x) / scale;
        const canvasMouseY = (mouseY - position.y) / scale;
        
        // Update all equipment items
        equipmentItems.forEach(item => {
          // Calculate new position relative to mouse position
          const itemCenterX = item.x + item.width / 2;
          const itemCenterY = item.y + item.height / 2;
          
          const dx = itemCenterX - canvasMouseX;
          const dy = itemCenterY - canvasMouseY;
          
          const newX = canvasMouseX + dx * scaleRatio;
          const newY = canvasMouseY + dy * scaleRatio;
          
          // Update item position and dimensions
          moveItem(item.id, 
                  newX - item.width * scaleRatio / 2, 
                  newY - item.height * scaleRatio / 2);
                  
          updateItemDimensions(item.id, 
                           item.width * scaleRatio, 
                           item.height * scaleRatio);
        });
      } else if (!imageLocked || !imageUrl) {
        // Normal canvas zooming when image is not locked
        const canvasMouseX = (mouseX - position.x) / scale;
        const canvasMouseY = (mouseY - position.y) / scale;
        
        const newX = mouseX - canvasMouseX * newScale;
        const newY = mouseY - canvasMouseY * newScale;
        
        setScale(newScale);
        setPosition({ x: newX, y: newY });
      }
    };
    
    canvas.addEventListener('wheel', wheelHandler, { passive: false });
    
    return () => {
      canvas.removeEventListener('wheel', wheelHandler);
    };
  }, [scale, position, setScale, setPosition, imageLocked, imageUrl, moveItem, updateItemDimensions, equipmentItems, selectedId]);
  
  // Keyboard shortcut handler
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Skip if we're in an input field or textarea
      if (event.target instanceof HTMLInputElement || 
          event.target instanceof HTMLTextAreaElement) {
        return;
      }
      
      // Common keyboard shortcuts
      switch (event.key) {
        case '+': // Zoom in
        case '=':
          event.preventDefault();
          useMapStore.getState().zoomIn();
          break;
        case '-': // Zoom out
          event.preventDefault();
          useMapStore.getState().zoomOut();
          break;
        case '0': // Reset zoom
          event.preventDefault();
          useMapStore.getState().resetZoom();
          break;
        case 'f': // Fit to screen
          event.preventDefault();
          useMapStore.getState().zoomToFit();
          break;
        case 'g': // Toggle grid
          event.preventDefault();
          useMapStore.getState().toggleGrid();
          break;
        case 'l': // Toggle image lock
          event.preventDefault();
          useMapStore.getState().setImageLocked(!imageLocked);
          break;
        case 'Escape': // Deselect equipment
          event.preventDefault();
          if (selectedId) selectItem(null);
          break;
        case 'Delete': // Delete selected equipment
        case 'Backspace':
          if (selectedId && document.activeElement === document.body) {
            event.preventDefault();
            useEquipmentStore.getState().removeItem(selectedId);
          }
          break;
      }
      
      // Arrow keys for fine movement of selected equipment
      if (selectedId) {
        const item = equipmentItems.find(i => i.id === selectedId);
        if (!item) return;
        
        const moveDistance = event.shiftKey ? 10 : 1; // Fine/coarse adjustment
        
        switch (event.key) {
          case 'ArrowLeft':
            event.preventDefault();
            moveItem(selectedId, item.x - moveDistance, item.y);
            break;
          case 'ArrowRight':
            event.preventDefault();
            moveItem(selectedId, item.x + moveDistance, item.y);
            break;
          case 'ArrowUp':
            event.preventDefault();
            moveItem(selectedId, item.x, item.y - moveDistance);
            break;
          case 'ArrowDown':
            event.preventDefault();
            moveItem(selectedId, item.x, item.y + moveDistance);
            break;
        }
      }
    };
    
    // Add keyboard event listener
    window.addEventListener('keydown', handleKeyDown);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [selectedId, equipmentItems, imageLocked, selectItem, moveItem]);

  return (
    <Box 
      ref={containerRef} 
      sx={{ 
        width: '100%', 
        height: '100%', 
        position: 'relative',
        overflow: 'hidden',
        bgcolor: '#121212'
      }}
    >
      <canvas
        ref={canvasRef}
        width={canvasSize.width}
        height={canvasSize.height}
        style={{
          width: '100%',
          height: '100%',
          display: 'block',
          cursor: isCalibrationMode ? 'crosshair' : 
                  isDraggingEquipment ? 'grabbing' : 
                  isPanning ? 'grabbing' : 'default'
        }}
        onClick={handleCanvasClick}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
      />
      
      {!imageUrl && (
        <Box
          sx={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'text.secondary',
            textAlign: 'center',
            p: 2
          }}
        >
          <Box sx={{ fontSize: '4rem', mb: 2 }}>🗺️</Box>
          <Typography variant="h6" sx={{ mb: 1 }}>No Image Loaded</Typography>
          <Typography variant="body2">
            Use the "Import Image" button above to load a satellite image
          </Typography>
        </Box>
      )}
      
      {imageUrl && (
        <Box
          sx={{
            position: 'absolute',
            bottom: 16,
            left: 16,
            bgcolor: 'rgba(0,0,0,0.7)',
            color: 'white',
            p: 1,
            borderRadius: 1,
            fontSize: '0.75rem'
          }}
        >
          Image loaded • Scale: {Math.round(scale * 100)}%
          {imageLocked && (
            <Box sx={{ mt: 0.5, color: 'warning.main' }}>
              🔒 Image Locked
            </Box>
          )}
          {activeCalibrationLine && (
            <Box sx={{ mt: 0.5 }}>
              Calibrated: {CalibrationService.formatDistance(activeCalibrationLine.realWorldDistance)}
            </Box>
          )}
          <Box sx={{ mt: 0.5, fontSize: '0.75rem', opacity: 0.7 }}>
            Zoom: {Math.round(scale * 100)}% • Grid: {showGrid ? 'ON' : 'OFF'}
          </Box>
        </Box>
      )}
      
      {isCalibrationMode && (
        <Box
          sx={{
            position: 'absolute',
            top: 16,
            left: '50%',
            transform: 'translateX(-50%)',
            bgcolor: 'rgba(255, 193, 7, 0.9)',
            color: 'black',
            p: 1,
            borderRadius: 1,
            fontSize: '0.875rem',
            fontWeight: 'bold'
          }}
        >
          📏 Calibration Mode: {currentCalibrationLine?.startPoint ? 'Click to set end point' : 'Click to set start point'}
        </Box>
      )}
      
      <CalibrationDialog
        open={calibrationDialogOpen}
        onClose={handleCalibrationDialogClose}
        onConfirm={handleCalibrationConfirm}
        pixelDistance={pendingCalibrationData?.pixelDistance || 0}
      />
    </Box>
  );
};

export default MapCanvas;
